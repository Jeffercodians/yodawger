#!/usr/bin/env bash

# @describe	Manage and invoke bundled docker services
# @meta	author	Kyle Smith <kyle@kmaismith.com>
# @meta	version	0.1.0
#credit: Jeff Lieb	Contributed the name "yodawger"

# @option -e --env Environment to manipulate

set -ueo pipefail
export SERVICES_IP SERVICES_ROOT="/yodawg"

source "${SERVICES_ROOT}/common/generics.sh"
source "${SERVICES_ROOT}/common/script_lib.sh"

SERVICES_IP="$(hostname -I | awk '{print $1}')"

# @cmd
services() {
	find "${SERVICES_ROOT}" \
		-maxdepth 1 -mindepth 1 \
		-name '*.service' | \
		xargs -rL1 basename | \
		tr '[:upper:]' '[:lower:]' | \
		sed -e 's/\.service$//'
	exit
}

yo() {
	env -i "${SERVICES_ROOT}/yodawger" "${@}"
}
export -f yo

# @cmd
# @alias	exec,s
# @meta	default-subcommand
# @arg	service		Name of the interface to interact with
# @arg	command		Command to invoke against the interface
# @arg	args~		Arguments to pass to the interface
yodawg() {
	if [ -f "${SERVICES_ROOT}/common/interfaces/${argc_service}" ]; then
		meta "${argc_service}" "${argc_command}" "${argc_args[@]}"
	else
		service "${argc_service}" "${argc_command}" "${argc_args[@]}"
	fi
}

meta() {
	local _name="${1}"
	local _command="${2}"
	local _args="${@:3}"

	"${SERVICES_ROOT}/common/interfaces/${_name}" \
		"${_command}" "${_args[@]}"
}

# @cmd
# @arg	name		Name of the service to interact with
# @arg	action		Command to invoke against the service
# @arg	args~		Arguments to pass to the command
service() {
	local _name="${argc_name:-"${1}"}"; shift
	local _action="${argc_action:-"${1}"}"; shift
	local -a _args="${argc_args[@]:-"${@}"}"
	local _env="${argc_env:-"${SERVICE_ENV:-"default"}"}"

	_discover_service "${_name}" "${_env}"

	_init_service

	"${SERVICE_ROOT}/bin/${SERVICE_NAME}" \
		"${_action}" \
		"${_args[@]}"
}

_discover_service() {
	local _name="${1}"
	local _env="${2}"

	export SERVICE_NAME SERVICE_ROOT SERVICE_ENV SERVICE_ENV_ROOT \
		ENV_ROOT SERVICE_CONF
	SERVICE_NAME="${_name}"
	SERVICE_ROOT="$(find "${SERVICES_ROOT}" \
			-maxdepth 1 -mindepth 1 \
			-iname "${SERVICE_NAME}.service")"
	if [ -f "${SERVICE_ROOT}/force-env" ]; then
		SERVICE_ENV="$(cat "${SERVICE_ROOT}/force-env" | xargs -r)"
	else
		SERVICE_ENV="${_env}"
	fi
	meta env exists "${SERVICE_ENV}" || \
		error "Yodawg environment ${SERVICE_ENV} does not exist"
	SERVICE_ENV_ROOT="${SERVICE_ROOT}/env/${SERVICE_ENV}"
	ENV_ROOT="${SERVICES_ROOT}/$(_env_path "${SERVICE_ENV}")/service/${SERVICE_NAME}"
	SERVICE_CONF="${SERVICE_ROOT}/conf"
}

_init_service() {
	export SERVICE_DATA SERVICE_ENV_CONF SERVICE_LOG SERVICE_CACHE

	[ "$(readlink -f "${SERVICE_ENV_ROOT}")" = "${ENV_ROOT}" ] || \
		_init_service_dir

	SERVICE_DATA="${SERVICE_ENV_ROOT}/data"
	SERVICE_ENV_CONF="${SERVICE_ENV_ROOT}/conf"
	SERVICE_LOG="${SERVICE_ENV_ROOT}/log"
	SERVICE_CACHE="${SERVICE_ENV_ROOT}/cache"

	mkdir -p "${SERVICE_DATA}" "${SERVICE_ENV_CONF}" \
		"${SERVICE_LOG}" "${SERVICE_CACHE}"

	_init_service_configs
}

_init_service_dir() {
	if [ -d "${SERVICE_ENV_ROOT}" ] && [ ! -d "${ENV_ROOT}" ]; then
		mkdir -p "$(dirname "${ENV_ROOT}")"
		mv "${SERVICE_ENV_ROOT}" "${ENV_ROOT}"
	elif [ ! -L "${SERVICE_ENV_ROOT}" ] && [ -d "${ENV_ROOT}" ]; then
		error "directory aleady exists for service ${SERVICE_NAME} in env ${SERVICE_ENV} (${ENV_ROOT})"
	else
		mkdir -p "${ENV_ROOT}"
	fi

	ln -sf "${ENV_ROOT}" "${SERVICE_ENV_ROOT}"
}

_init_service_configs() {
	set -a
	if [ -f "${SERVICE_ROOT}/config.sh" ]; then
		source "${SERVICE_ROOT}/config.sh"
	fi
	if [ -f "${SERVICE_ENV_ROOT}/config.sh" ]; then
		source "${SERVICE_ENV_ROOT}/config.sh"
	fi
}

eval "$(argc --argc-eval "${0}" "${@}")"
